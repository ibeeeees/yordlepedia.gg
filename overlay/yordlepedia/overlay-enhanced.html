<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Yordlepedia Overlay</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: transparent;
            color: #f0e6d2;
            overflow: hidden;
            width: 1920px;
            height: 1080px;
            position: relative;
        }

        /* Draggable container for each panel */
        .draggable-panel {
            position: absolute;
            cursor: default;
        }

        .draggable-panel.edit-mode {
            cursor: move;
            border: 2px dashed #00ff88 !important;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.5) !important;
        }

        .draggable-panel.edit-mode:hover {
            border-color: #ffff00 !important;
        }

        /* Edit Mode Banner */
        .edit-mode-banner {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 255, 136, 0.95);
            color: #0a1428;
            padding: 30px 50px;
            border-radius: 12px;
            font-size: 24px;
            font-weight: bold;
            text-align: center;
            display: none;
            z-index: 9999;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.8);
        }

        .edit-mode-banner.visible {
            display: block;
        }

        .edit-mode-instructions {
            font-size: 14px;
            margin-top: 10px;
            font-weight: normal;
        }

        /* Loading Badge (Top Left) */
        .loading-badge {
            background: rgba(10, 20, 40, 0.9);
            padding: 12px 20px;
            border-radius: 8px;
            border: 2px solid #0bc6e3;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            font-size: 14px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
            z-index: 1000;
        }

        .loading-badge.connected {
            border-color: #00ff88;
        }

        .loading-badge.disconnected {
            border-color: #ff4458;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #0bc6e3;
            animation: pulse 2s infinite;
        }

        .status-dot.connected {
            background: #00ff88;
        }

        .status-dot.disconnected {
            background: #ff4458;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Player Stats Panel (Top Right) */
        .stats-panel {
            background: rgba(10, 20, 40, 0.95);
            padding: 20px;
            border-radius: 12px;
            border: 2px solid #c89b3c;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.6);
            min-width: 300px;
            display: none;
        }

        .stats-panel.visible {
            display: block;
        }

        .stats-header {
            font-size: 18px;
            font-weight: bold;
            color: #c89b3c;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(200, 155, 60, 0.3);
        }

        .stat-item:last-child {
            border-bottom: none;
        }

        .stat-label {
            color: #a09b8c;
            font-size: 14px;
        }

        .stat-value {
            color: #f0e6d2;
            font-weight: bold;
            font-size: 14px;
        }

        .stat-value.positive {
            color: #00ff88;
        }

        .stat-value.negative {
            color: #ff4458;
        }

        /* AI Tips Box (Center) */
        .ai-tip-box {
            background: rgba(10, 20, 40, 0.98);
            padding: 25px 30px;
            border-radius: 12px;
            border: 3px solid #c89b3c;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.7);
            max-width: 600px;
            display: none;
            animation: fadeIn 0.3s ease-in;
        }

        .ai-tip-box.visible {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .tip-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .tip-title {
            font-size: 16px;
            font-weight: bold;
            color: #c89b3c;
            text-transform: uppercase;
        }

        .tip-priority {
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
        }

        .tip-priority.low {
            background: #00ff88;
            color: #0a1428;
        }

        .tip-priority.medium {
            background: #ff9800;
            color: #0a1428;
        }

        .tip-priority.high {
            background: #ff4458;
            color: #ffffff;
        }

        .tip-content {
            color: #f0e6d2;
            font-size: 14px;
            line-height: 1.6;
        }
    </style>
</head>
<body>
    <!-- Edit Mode Banner -->
    <div class="edit-mode-banner" id="edit-mode-banner">
        <div>ðŸŽ¨ EDIT MODE ACTIVE</div>
        <div class="edit-mode-instructions">
            Drag panels to reposition â€¢ Changes save automatically
        </div>
    </div>

    <!-- Loading/Connection Badge -->
    <div class="draggable-panel loading-badge disconnected" id="connection-badge" data-panel="connection">
        <div class="status-dot disconnected" id="status-dot"></div>
        <span id="connection-text">Waiting for League Client...</span>
    </div>

    <!-- Player Stats Panel -->
    <div class="draggable-panel stats-panel" id="stats-panel" data-panel="stats">
        <div class="stats-header">Your Stats</div>
        <div class="stat-item">
            <span class="stat-label">Level</span>
            <span class="stat-value" id="level">1</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">CS</span>
            <span class="stat-value" id="cs">0</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">CS/min</span>
            <span class="stat-value" id="cs-per-min">0.0</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">Gold/min</span>
            <span class="stat-value" id="gold-per-min">0</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">Team Gold</span>
            <span class="stat-value" id="team-gold">0</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">Vision/min</span>
            <span class="stat-value" id="vision-per-min">0.0</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">Gold Diff</span>
            <span class="stat-value" id="gold-diff">0</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">KDA</span>
            <span class="stat-value" id="kda">0/0/0</span>
        </div>
    </div>

    <!-- AI Tip Box -->
    <div class="draggable-panel ai-tip-box" id="ai-tip-box" data-panel="tips">
        <div class="tip-header">
            <span class="tip-title">AI Coach Tip</span>
            <span class="tip-priority medium" id="tip-priority">Medium</span>
        </div>
        <div class="tip-content" id="tip-content">
            Focus on farming under tower. Your CS/min is below target. Try to secure cannon minions for extra gold.
        </div>
    </div>

    <script>
        /**
         * ENHANCED OVERLAY RENDERER WITH EDIT MODE
         *
         * Features:
         * - Draggable panels in edit mode
         * - Position persistence via localStorage
         * - Transparency control
         * - Testing mode support
         */

        // ==================== STATE MANAGEMENT ====================
        let isEditMode = false;
        let draggedElement = null;
        let offsetX = 0;
        let offsetY = 0;

        // Default panel positions
        const DEFAULT_POSITIONS = {
            connection: { top: 20, left: 20 },
            stats: { top: 20, right: 20 },
            tips: { top: '50%', left: '50%', transform: 'translate(-50%, -50%)' }
        };

        // ==================== POSITION MANAGEMENT ====================

        /**
         * Load saved panel positions
         */
        function loadPanelPositions() {
            try {
                const saved = localStorage.getItem('yordlepedia-panel-positions');
                if (saved) {
                    return JSON.parse(saved);
                }
            } catch (error) {
                console.error('Error loading panel positions:', error);
            }
            return DEFAULT_POSITIONS;
        }

        /**
         * Save panel positions
         */
        function savePanelPositions(positions) {
            try {
                localStorage.setItem('yordlepedia-panel-positions', JSON.stringify(positions));
                console.log('âœ… Panel positions saved');
            } catch (error) {
                console.error('âŒ Error saving positions:', error);
            }
        }

        /**
         * Apply saved positions to panels
         */
        function applyPanelPositions() {
            const positions = loadPanelPositions();
            const panels = document.querySelectorAll('.draggable-panel');

            panels.forEach(panel => {
                const panelId = panel.getAttribute('data-panel');
                const pos = positions[panelId];

                if (pos) {
                    // Clear existing position styles
                    panel.style.top = '';
                    panel.style.right = '';
                    panel.style.bottom = '';
                    panel.style.left = '';
                    panel.style.transform = '';

                    // Apply saved position
                    Object.keys(pos).forEach(key => {
                        panel.style[key] = typeof pos[key] === 'number' ? `${pos[key]}px` : pos[key];
                    });
                }
            });
        }

        /**
         * Get current panel position
         */
        function getPanelPosition(panel) {
            const panelId = panel.getAttribute('data-panel');
            return {
                top: panel.offsetTop,
                left: panel.offsetLeft
            };
        }

        // ==================== EDIT MODE ====================

        /**
         * Toggle edit mode
         */
        function toggleEditMode(enabled) {
            isEditMode = enabled;
            const panels = document.querySelectorAll('.draggable-panel');
            const banner = document.getElementById('edit-mode-banner');

            if (enabled) {
                panels.forEach(panel => {
                    panel.classList.add('edit-mode');
                    // Make visible for editing
                    if (panel.id === 'stats-panel' || panel.id === 'ai-tip-box') {
                        panel.classList.add('visible');
                    }
                });
                banner.classList.add('visible');
                console.log('âœï¸ Edit mode enabled');
            } else {
                panels.forEach(panel => {
                    panel.classList.remove('edit-mode');
                });
                banner.classList.remove('visible');
                console.log('âœ… Edit mode disabled');
            }
        }

        /**
         * Start dragging
         */
        function startDrag(e) {
            if (!isEditMode) return;

            draggedElement = e.target.closest('.draggable-panel');
            if (!draggedElement) return;

            const rect = draggedElement.getBoundingClientRect();
            offsetX = e.clientX - rect.left;
            offsetY = e.clientY - rect.top;

            draggedElement.style.transform = 'none'; // Remove any transform for absolute positioning
            draggedElement.style.right = 'auto';
            draggedElement.style.bottom = 'auto';

            console.log('ðŸ–±ï¸ Dragging:', draggedElement.getAttribute('data-panel'));
        }

        /**
         * Drag element
         */
        function drag(e) {
            if (!draggedElement) return;

            const newLeft = e.clientX - offsetX;
            const newTop = e.clientY - offsetY;

            // Keep within bounds
            const maxX = window.innerWidth - draggedElement.offsetWidth;
            const maxY = window.innerHeight - draggedElement.offsetHeight;

            draggedElement.style.left = `${Math.max(0, Math.min(newLeft, maxX))}px`;
            draggedElement.style.top = `${Math.max(0, Math.min(newTop, maxY))}px`;
        }

        /**
         * End dragging and save position
         */
        function endDrag() {
            if (!draggedElement) return;

            const panelId = draggedElement.getAttribute('data-panel');
            const position = getPanelPosition(draggedElement);

            // Save all positions
            const positions = loadPanelPositions();
            positions[panelId] = position;
            savePanelPositions(positions);

            console.log(`ðŸ’¾ Saved ${panelId} position:`, position);
            draggedElement = null;
        }

        // ==================== DRAG EVENT LISTENERS ====================

        document.addEventListener('mousedown', startDrag);
        document.addEventListener('mousemove', drag);
        document.addEventListener('mouseup', endDrag);

        // ==================== IPC COMMUNICATION ====================

        if (window.electronAPI) {
            // Listen for connection status updates
            window.electronAPI.onConnectionStatus((status) => {
                console.log('Connection status:', status);

                const badge = document.getElementById('connection-badge');
                const dot = document.getElementById('status-dot');
                const text = document.getElementById('connection-text');

                if (status.connected && status.inGame) {
                    badge.className = 'draggable-panel loading-badge connected';
                    dot.className = 'status-dot connected';
                    text.textContent = 'Connected - In Game';

                    // Show stats panel
                    if (!isEditMode) {
                        document.getElementById('stats-panel').classList.add('visible');
                    }
                } else if (status.connected) {
                    badge.className = 'draggable-panel loading-badge connected';
                    dot.className = 'status-dot connected';
                    text.textContent = `Connected - ${status.phase || 'Lobby'}`;

                    if (!isEditMode) {
                        document.getElementById('stats-panel').classList.remove('visible');
                    }
                } else {
                    badge.className = 'draggable-panel loading-badge disconnected';
                    dot.className = 'status-dot disconnected';
                    text.textContent = status.message || 'Waiting for League Client...';

                    if (!isEditMode) {
                        document.getElementById('stats-panel').classList.remove('visible');
                    }
                }

                // Re-apply edit mode classes if active
                if (isEditMode) {
                    badge.classList.add('edit-mode');
                }
            });

            // Listen for game data updates
            window.electronAPI.onGameDataUpdate((data) => {
                console.log('Game data update:', data);
                updatePlayerStats(data);
            });

            // Listen for AI tip toggle
            window.electronAPI.onToggleTipBox((show) => {
                const tipBox = document.getElementById('ai-tip-box');
                if (show) {
                    tipBox.classList.add('visible');
                } else {
                    tipBox.classList.remove('visible');
                }
            });

            // Listen for edit mode toggle
            window.electronAPI.onEditModeToggle?.((enabled) => {
                toggleEditMode(enabled);
            });

            // Listen for transparency changes
            window.electronAPI.onTransparencyChange?.((opacity) => {
                document.body.style.opacity = opacity;
            });

            // Listen for reset positions
            window.electronAPI.onResetPositions?.(() => {
                console.log('ðŸ”„ Resetting panel positions to defaults');
                localStorage.removeItem('yordlepedia-panel-positions');
                applyPanelPositions();
            });
        } else {
            console.error('âŒ electronAPI not available');
        }

        // ==================== GAME DATA UPDATE ====================

        function updatePlayerStats(data) {
            console.log('ðŸ“Š Updating player stats');

            if (!data || !data.activePlayer) {
                console.warn('âš ï¸ No active player data available');
                return;
            }

            const player = data.activePlayer;
            const allGameData = data.allGameData;

            // Get game time in minutes
            const gameTime = allGameData?.gameData?.gameTime || 0;
            const gameTimeMinutes = gameTime > 0 ? gameTime / 60 : 0.01;

            // Level
            if (player.level !== undefined) {
                document.getElementById('level').textContent = player.level;
            }

            // Gold/min
            const currentGold = player.currentGold || 0;
            if (gameTime > 0) {
                const goldPerMin = Math.round(currentGold / gameTimeMinutes);
                document.getElementById('gold-per-min').textContent = goldPerMin;
            }

            // Find player's scores in allGameData.allPlayers
            if (allGameData && allGameData.allPlayers && allGameData.allPlayers.length > 0) {
                const playerName = player.summonerName;
                const playerData = allGameData.allPlayers.find(p => p.summonerName === playerName);

                if (playerData && playerData.scores) {
                    // CS (Creep Score)
                    const creepScore = playerData.scores.creepScore || 0;
                    document.getElementById('cs').textContent = creepScore;
                    console.log('ðŸŒ¾ CS:', creepScore);

                    // CS/min
                    if (gameTime > 0) {
                        const csPerMin = (creepScore / gameTimeMinutes).toFixed(1);
                        document.getElementById('cs-per-min').textContent = csPerMin;
                        console.log('ðŸ“Š CS/min:', csPerMin);
                    }

                    // KDA
                    const kills = playerData.scores.kills || 0;
                    const deaths = playerData.scores.deaths || 0;
                    const assists = playerData.scores.assists || 0;
                    document.getElementById('kda').textContent = `${kills}/${deaths}/${assists}`;
                    console.log('âš”ï¸ KDA:', `${kills}/${deaths}/${assists}`);

                    // Vision/min
                    const wardScore = playerData.scores.wardScore || 0;
                    if (gameTime > 0) {
                        const visionPerMin = (wardScore / gameTimeMinutes).toFixed(1);
                        document.getElementById('vision-per-min').textContent = visionPerMin;
                        console.log('ðŸ‘ï¸ Vision/min:', visionPerMin);
                    }

                    // Calculate team stats
                    calculateTeamStats(allGameData, player, gameTimeMinutes);
                } else {
                    console.warn('âš ï¸ Player data or scores not available yet');
                }
            } else {
                console.warn('âš ï¸ Game data not fully loaded yet');
            }
        }

        function calculateTeamStats(allGameData, activePlayer, gameTimeMinutes) {
            const allPlayers = allGameData.allPlayers;
            const activePlayerName = activePlayer.summonerName;
            const activePlayerData = allPlayers.find(p => p.summonerName === activePlayerName);

            if (!activePlayerData) return;

            const activePlayerTeam = activePlayerData.team;

            // Accurate gold calculation
            const GOLD_VALUES = {
                CS_AVG: 21,
                KILL: 300,
                ASSIST: 150,
                BASE_GOLD_RATE: 116.67
            };

            let teamGold = 0;
            let enemyGold = 0;

            allPlayers.forEach(player => {
                if (!player.scores) return;

                const csGold = (player.scores.creepScore || 0) * GOLD_VALUES.CS_AVG;
                const killGold = (player.scores.kills || 0) * GOLD_VALUES.KILL;
                const assistGold = (player.scores.assists || 0) * GOLD_VALUES.ASSIST;
                const passiveGold = gameTimeMinutes * GOLD_VALUES.BASE_GOLD_RATE;

                const estimatedGold = csGold + killGold + assistGold + passiveGold;

                if (player.team === activePlayerTeam) {
                    teamGold += estimatedGold;
                } else {
                    enemyGold += estimatedGold;
                }
            });

            document.getElementById('team-gold').textContent = Math.round(teamGold);

            // Gold Diff
            const goldDiff = teamGold - enemyGold;
            const goldDiffElement = document.getElementById('gold-diff');
            goldDiffElement.textContent = goldDiff > 0 ? `+${Math.round(goldDiff)}` : Math.round(goldDiff);

            if (goldDiff > 0) {
                goldDiffElement.className = 'stat-value positive';
            } else if (goldDiff < 0) {
                goldDiffElement.className = 'stat-value negative';
            } else {
                goldDiffElement.className = 'stat-value';
            }
        }

        // ==================== INITIALIZATION ====================

        // Apply saved positions on load
        applyPanelPositions();

        console.log('âœ… Enhanced overlay renderer loaded');
    </script>
</body>
</html>
